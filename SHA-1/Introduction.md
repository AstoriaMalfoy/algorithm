#SHA-1 算法
****
* SHA-1（Secure Hash Algorithm）是安全散列算法1，一种密码散列函数SHA-1可以生成一个160位（20字节）的消息摘要散列值。散列值的通常表示形式为40个十六进制的数。
* SHA-1 已经不再认为可以抵御资金充足，充足计算资源的攻击，许多的企业和组织建议使用SHA-2或者SHA-3来代替SHA-1，并且诸多浏览器厂商已经不再支持SHA-1签名的证书。
* SHA-1 可以对消息长度不大于2^64比特的消息进行计算，输入以512位数据块进为单位行处理，产生160位比特的消息摘要作为输出。

## 算法实现步骤
* ###附加填充比特位(补位)
    * 对于输入的数据块，对其进行附加填充，要求其对512求余为448，填充的数据为最高位为1，其位为0，附加填充是总存在的，即使输入的数据块为512字节。
* ###附加填充比特位(补长度)
    * 所谓的补充长度就是在原始数据的后面添加一个记录长度的比特串，因为这里只能使用64为来表示长度，所以也就限制了SHA1算法能够处理的数据的长度不能大于2^64，
* ###存储使用常量
    * 一些列使用的常量值K(0),K(1),K(2),....,K(79).以16进制给出为如下
        * K<sub>t</sub> = 0x5A827999 ( 0<=t<=19)
        * K<sub>t</sub> = 0x6ED9EBA1 (20<=t<=39)
        * K<sub>t</sub> = 0x8F1BBCDC (40<=t<=59)
        * K<sub>t</sub> = 0xCA62C1D6 (60<=t<=79)
* ###需要使用的相关计算函数
    * 在计算SHA1的时候我们需要使用一些列的函数，每个函数f<sub>t</sub>(B,C,D)都操作32位数据B,C,D。并且产生32位作为输出
    * f<sub>t</sub>(B,C,D)可以使用如下来进行表示
        * f<sub>t</sub>(B,C,D) = (B AND C) OR ((NOT B) AND D) (0 <= t <= 19)
        * f<sub>t</sub>(B,C,D) = B XOR C XOR D (20 <= t <= 39)
        * f<sub>t</sub>(B,C,D) = (B AND C) OR (B AND D) OR (C AND D) (40 <= t <= 59)
        * f<sub>t</sub>(B,C,D) = B XOR C XOR D (60 <= t <= 79)
* ###计算消息摘要
    * 计算信息摘要需要将原有的512位明文分为16个明文分组，每个明文分组32位。
    * 申请5个32位的链接变量，为 A,B,C,D,E
    * 将16个明文分组扩展成80个明文分组
    * 进行4轮计算
    * 链接变量和初始链接变量进行求和计算
    * 链接变量作为下一个分组计算的输入进行计算
    * 最后得到的5个链接变量就是SHA1摘要
* ###16个明文分组扩展成80个明文分组的过程
    * 这里约定M<sub>t</sub>为初始的16个明文分组，约定W<sub>t</sub>为扩展的80个明文分组，那么则有：
        * W<sub>t</sub> = M<sub>t</sub> (0<=t<=15)
        * W<sub>t</sub> = (W<sub>t-3</sub>&bigoplus;W<sub>t-8</sub>&bigoplus;W<sub>t-14</sub>&bigoplus;W<sub>t-16</sub> (16<=t<=79)
* ###摘要计算轮次
    * SHA1需要进行4轮次计算，每轮需要计算需要20个步骤，最后产生160位的摘要，并且这160位摘要需要保存在5个32位的变量中，分别为A,B,C,D,E,这5个变量的初始值为
        * A=0x67452301
        * B=0xEFCDAB89
        * C=0x98BADCFE
        * D=0x10325476
        * E=0xC3D2E1F0
    *SHA1的每轮计算都符合下面的计算公式：
        * A,B,C,D,E←[(A<<<5)+ ft(B,C,D)+E+W<sub>t</sub>+K<sub>t</sub>],A,(B<<<30),C,D 